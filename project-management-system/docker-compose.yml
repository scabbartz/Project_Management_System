version: '3.8'

services:
  server:
    build:
      context: ./server
      dockerfile: Dockerfile
    image: project-management-system-server:latest # Define an image name
    container_name: pms_server
    ports:
      - "3001:3001" # Map host port 3001 to container port 3001
    volumes:
      # For development, you might want to mount the src directory:
      # - ./server/src:/usr/src/app/src
      # However, for production build as per Dockerfile, this is not needed.
      # The Dockerfile handles copying and building the code.
      # If you want live reload for dev, the Dockerfile and CMD would need to change (e.g. use nodemon).
      # For now, this setup is more aligned with a production-like build.
      - ./server/logs:/usr/src/app/logs # Example if server writes logs to a file, ensure logs dir is created
    environment:
      - NODE_ENV=development # Or 'production' depending on the use case for docker-compose
      - PORT=3001
      # - DATABASE_URL=postgresql://user:password@db_host:5432/pms_db # To be added later
    restart: unless-stopped
    networks:
      - pms_network

  # client: # Client service can be added later, potentially served via Nginx or directly
  #   build:
  #     context: ./client
  #     dockerfile: Dockerfile # A Dockerfile for client would be needed
  #   ports:
  #     - "3000:3000"
  #   container_name: pms_client
  #   depends_on:
  #     - server
  #   networks:
  #     - pms_network

  # postgres_db: # PostgreSQL service will be added in a later sprint
  #   image: postgres:15
  #   container_name: pms_postgres_db
  #   environment:
  #     - POSTGRES_USER=admin
  #     - POSTGRES_PASSWORD=secret
  #     - POSTGRES_DB=pms_dev_db
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data
  #   restart: unless-stopped
  #   networks:
  #     - pms_network

networks:
  pms_network:
    driver: bridge

# volumes: # Define persistent volume for PostgreSQL data
#   postgres_data:
#     driver: local
